# Эмулятор процессора - Вариант №9

## Описание

Эмулятор процессора с одноадресной архитектурой Фон-Неймана, реализованный на Python. Проект выполнен в рамках учебного задания по курсу "Микропроцессоры и вычислительные машины".

## Архитектура процессора

### Компоненты
- **Аккумулятор (ACC)** - 16 бит, основной регистр для вычислений
- **Счетчик команд (PC)** - 16 бит, указывает на текущую команду
- **Регистр команд (IR)** - 16 бит, содержит текущую команду
- **Регистр флагов** - 8 бит (ZF, SF, CF, OF)
- **ОЗУ** - 4096 ячеек по 16 бит

### Формат команды (16 бит)
```
[15:12] - Код операции (4 бита)
[11:0]  - Адрес/операнд (12 бит)
```

### Система команд

| Код | Мнемоника | Описание | Типы адресации |
|-----|-----------|----------|----------------|
| 0x1 | LOAD      | Загрузка в аккумулятор | Непосредственная, Прямая, Косвенная |
| 0x2 | STORE     | Сохранение из аккумулятора | Прямая, Косвенная |
| 0x3 | ADD       | Сложение | Непосредственная, Прямая, Косвенная |
| 0x4 | SUB       | Вычитание | Непосредственная, Прямая, Косвенная |
| 0x5 | CMP       | Сравнение | Непосредственная, Прямая, Косвенная |
| 0x6 | JMP       | Безусловный переход | Прямая |
| 0x7 | JZ        | Переход если ноль | Прямая |
| 0x8 | JNZ       | Переход если не ноль | Прямая |
| 0x0 | HALT      | Остановка | - |

### Типы адресации

1. **Непосредственная** - `#value` (значение в команде)
2. **Прямая** - `address` (адрес в памяти)
3. **Косвенно-регистровая** - `(address)` (адрес по адресу)
4. **Регистровая** - `R0` (аккумулятор)

## Структура проекта

```
emulator/
├── processor.py          # Основной класс процессора
├── assembler.py          # Ассемблер для парсинга команд
├── gui.py               # Графический интерфейс
├── programs/            # Примеры программ
│   ├── max_search.asm   # Поиск максимума в массиве
│   └── convolution.asm  # Свертка двух массивов
├── tests/               # Тесты
│   └── test_processor.py
├── requirements.txt     # Зависимости
└── README.md           # Документация
```

## Установка и запуск

### Требования
- Python 3.7+
- tkinter (встроен в Python)
- numpy (для расширенной визуализации)
- matplotlib (для графиков и диаграмм)

### Установка зависимостей
```bash
pip install -r requirements.txt
```

### Варианты запуска

#### Базовый интерфейс
```bash
python gui.py
```

#### Интерфейс с визуализацией потока данных
```bash
python visual_gui.py
```

#### Расширенный интерфейс с аналитикой
```bash
python enhanced_gui.py
```

#### Основной файл (базовый интерфейс)
```bash
python main.py
```

### Запуск тестов
```bash
python -m pytest tests/
# или
python tests/test_processor.py
```

## Примеры программ

### 1. Поиск максимума в массиве

```asm
; Данные: memory[300] = размер массива, далее элементы без знака
; Результат (максимум) сохраняется по адресу 100

START:
    LOAD #0
    STORE 100        ; max = 0
    STORE 101        ; i = 0

    LOAD #300
    STORE 102        ; базовый адрес массива
    LOAD (102)
    STORE 104        ; размер массива

LOOP:
    LOAD 101
    CMP 104
    JZ END

    LOAD 102
    ADD #1
    ADD 101
    STORE 103        ; адрес элемента

    LOAD (103)
    STORE 108        ; значение элемента

    LOAD 108
    STORE 105        ; копия элемента
    LOAD 100
    STORE 106        ; копия текущего максимума

    LOAD #0
    STORE 107        ; флаг обновления

COMPARE_LOOP:
    LOAD 105
    JZ CHECK_MAX_DONE

    LOAD 106
    JZ ELEMENT_GREATER

    LOAD 105
    SUB #1
    STORE 105

    LOAD 106
    SUB #1
    STORE 106
    JMP COMPARE_LOOP

CHECK_MAX_DONE:
    LOAD 106
    JZ COMPARE_END
    JMP COMPARE_END

ELEMENT_GREATER:
    LOAD #1
    STORE 107
    JMP COMPARE_END

COMPARE_END:
    LOAD 107
    JZ SKIP_UPDATE

    LOAD 108
    STORE 100        ; обновляем максимум

SKIP_UPDATE:
    LOAD 101
    ADD #1
    STORE 101
    JMP LOOP

END:
    HALT
```

### 2. Свертка двух массивов

```asm
; Массив A хранится с адреса 300, массив B — с адреса 320
; Первый элемент каждого массива — количество последующих значений (6)
; Сумма произведений сохраняется по адресу 100

START:
    LOAD #0
    STORE 100        ; sum = 0
    STORE 101        ; i = 0

    LOAD #300
    STORE 102        ; база A
    LOAD #320
    STORE 103        ; база B

    LOAD (102)
    STORE 110        ; размер массивов

LOOP:
    LOAD 101
    CMP 110
    JZ END

    LOAD 102
    ADD #1
    ADD 101
    STORE 104
    LOAD (104)
    STORE 106        ; A[i]

    LOAD 103
    ADD #1
    ADD 101
    STORE 105
    LOAD (105)
    STORE 107        ; B[i]

    LOAD 107
    STORE 109        ; счётчик умножения
    LOAD #0
    STORE 108        ; произведение

MULT_LOOP:
    LOAD 109
    JZ MULT_DONE

    LOAD 108
    ADD 106
    STORE 108

    LOAD 109
    SUB #1
    STORE 109
    JMP MULT_LOOP

MULT_DONE:
    LOAD 100
    ADD 108
    STORE 100

    LOAD 101
    ADD #1
    STORE 101
    JMP LOOP

END:
    HALT
```

## Использование GUI

### Базовый интерфейс (gui.py)
1. **Загрузка программы**: Введите код на ассемблере в текстовое поле
2. **Ассемблирование**: Нажмите "Ассемблировать" для компиляции
3. **Загрузка в процессор**: Нажмите "Загрузить в процессор"
4. **Выполнение**: Используйте кнопки "Шаг" или "Запуск"
5. **Мониторинг**: Следите за состоянием регистров и флагов

### Визуальный интерфейс (visual_gui.py)
**Новые возможности:**
- **Схематическое представление**: Визуальная схема процессора с компонентами
- **Анимация потока данных**: Движущиеся элементы показывают передачу данных
- **Подсветка активных компонентов**: Активные части процессора подсвечиваются
- **Регулируемая скорость**: Слайдер для управления скоростью анимации
- **Детальное логирование**: Подробный лог выполнения каждой инструкции

**Компоненты визуализации:**
- Аккумулятор (ACC) - зеленый прямоугольник
- Счетчик команд (PC) - синий прямоугольник  
- Регистр команд (IR) - желтый прямоугольник
- АЛУ - красный прямоугольник
- Блок управления - фиолетовый прямоугольник
- Память (ОЗУ) - оранжевый прямоугольник
- Шина данных - серый прямоугольник
- Флаги - розовый прямоугольник

### Расширенный интерфейс (enhanced_gui.py)
**Дополнительные возможности:**
- **Графики производительности**: Статистика выполненных команд
- **История регистров**: График изменения значений регистров во времени
- **Карта памяти**: Визуализация обращений к памяти
- **Детальное декодирование**: Разбор каждой команды на составляющие
- **Трассировка выполнения**: Полная история выполнения программы
- **Экспорт данных**: Сохранение статистики и трассировки в файлы
- **Множественные форматы**: Отображение данных в десятичном, шестнадцатеричном и двоичном виде

**Аналитические возможности:**
1. **Статистика команд**: Круговая диаграмма частоты использования команд
2. **График регистров**: Линейный график изменения значений ACC, PC, IR
3. **Карта памяти**: Scatter-plot обращений к различным адресам памяти
4. **Профилирование**: Анализ производительности и узких мест программы

## Особенности реализации

- **RISC-архитектура** с фиксированной длиной команд (16 бит)
- **Одноадресные команды** с поддержкой 4 типов адресации
- **Графический интерфейс** с отображением всех регистров
- **Встроенный ассемблер** с поддержкой меток
- **Автоматическое обновление** интерфейса в реальном времени
- **Тестирование** всех компонентов системы

## Технические детали

- **Размер команд**: 16 бит
- **Размер памяти**: 4096 ячеек по 16 бит
- **Размер регистров**: 16 бит
- **Поддерживаемые типы данных**: 16-битные целые числа (со знаком и без знака)
- **Система команд**: 9 команд с различными типами адресации

## Автор

Проект выполнен в рамках учебного задания по курсу "Микропроцессоры и вычислительные машины".

## Лицензия

Учебный проект для образовательных целей.
